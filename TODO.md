# 项目扩展 TODO

## 项目全局

1. RPC 请求类中支持携带参数列表，可以用于安全校验。比如服务提供者参数列表、服务消费者参数列表，服务端接收到请求后可以根据参数列表中的值，判断如何进一步处理，比如在参数列表中携带
   token 可以实现安全校验。📅
2. 项目支持读取 `.yml / .yaml` 等不同格式的配置文件，作为全局配置。仿照现有的 `ConfigUtil`
   工具类，支持更多读取配置的方式，甚至可以使用 SPI 机制允许开发则二次扩展配置解析器。 ✅
3. 实现拦截器机制，服务调用前和服务调用后可以执行额外的操作。可以参考 SpringMVC 或者 Servlet 的 Filter
   机制，使用责任链模式实现；可以在服务提供者处理前后、服务消费者调用前后增加拦截器，用于进行日志校验、安全校验等。还可以使用
   SPI 机制，支持用户自定义拦截器。📅
4. 自定义异常。自定义异常类 `RpcException`，根据业务区分错误码，比如消费者异常、注册中心异常、提供者异常等等，让报错信息更清晰明确。 📅
5. 服务支持指定版本号。目前已经预留了版本字段，但都是默认值，还需要从服务提供者再到消费者代理调用的一条完整路径上应用版本号。📅
6. 支持消费方指定某个服务级别的负载均衡器、重试策略、容错机制。目前只能通过全局配置改变对所有服务的负载均衡调用规则。实现的话可能需要修改 `ServiceProxy`
   类，让它支持传参，根据消费者端的配置来动态创建 `ServiceProxy`。 📅
7. ~~支持指定服务分组：服务提供者和服务消费者可以指定分组，服务消费者在调用服务提供者时，只调用指定分组的提供者。目前已经预留了服务分组字段，用默认值填充。还需要从服务提供者、再到服务消费者代理调用的一条完整路径上应用服务分组。可以进一步实现多环境功能。~~
8. 服务消费方支持设定超时时间。可以通过修改 TCP 客户端请求相关的代码实现。📅
9. ~~处理 Bean 注入的问题：目前本地服务注册表存储的是 Class，然后通过反射创建实例，但是如果 Bean 包含有参构造函数，或者给属性注入了其他实例，这种方式就行不通了。本地注册时需要放入实现类的对象实例，而不是 Class 类型。~~

## 全局配置

1. 支持读取 `.yml / .yaml` 等不同格式的配置文件 ✅
2. 配置文件支持中文，注意编码问题 ✅
3. ~~配置分组，考虑通过嵌套配置类的方式实现~~

## RPC Mock

1. 完善 Mock 的逻辑，支持更多类型的默认值生成，考虑使用 Faker 之类的库来伪造数据生成，生成默认值 ✅

## 序列化

1. 实现更多不同协议的序列化器，比如 `Protobuf`、`Hessian`、`FastJson` 等等 ✅
2. 序列化工厂懒加载的方式创建序列化器实例 ✅

## SPI

1. `SpiLoader` 支持懒加载，获取实例时才加载对应的类 ✅

## 注册中心

1. 完善服务注册信息：节点注册时间等等 ✅
2. 实现更多注册中心：比如 Redis ✅
3. 保证注册中心的高可用：集群
4. ~~服务注册信息失效的兜底策略：如果有消费端调用节点时发现节点失效，可以考虑是否需要从注册中心更新服务注册信息、或者强制更新本地缓存~~
5. ~~注册中心 Key 监听，采用观察者模式实现：定义一个 `Listener` 接口，根据 `watch key`
   的变更去调用 `Listener` 的不同方法~~

## 自定义协议

1. ~~定义一个占用空间更少的 RPC 协议的消息结构，比如 序列化字段目前占用 8bit，但其实总共也就几种序列化方式，能够更精简等等~~

## 负载均衡

1. ~~实现更多算法的负载均衡器，比如最少活跃数负载均衡器，选择当前正在处理请求的数量最少的服务提供者~~
2. ~~自定义一致性 Hash 算法中的 Hash 算法，比如根据请求客户端的 IP 地址来计算 Hash 值，保证同 IP
   的请求发送给相同的服务提供者~~

## 重试机制

1. 新增更多的不同类型的重试器 ✅

## 容错机制

1. 实现 `Fail-Back` 机制，参考 Dubbo Mock 能力，让消费端调用失败后执行本地服务和方法 ✅
2. 实现 `Fail-Over` 机制，利用容错上下文传递服务节点参数和本地调用的服务节点 ✅
3. 实现更多容错方案，比如限流、熔断、超时控制等；或者将重试机制作为容错机制的一种策略来实现 ✅

## 启动机制

1. Starter 支持读取 yml / yaml 配置文件来启动 RPC 框架 ✅
2. 服务提供者启动逻辑也可以将 bean 后置执行改为「使用组件扫描」