# 项目扩展 TODO

## 全局配置

1. 支持读取 `.yml / .yaml` 等不同格式的配置文件
2. 支持监听配置文件的变更，并自动更新配置对象：可以考虑使用 `Hutool` 的 `Props#autoLoad()`
   ，实现配置文件变更的监听和自动加载
3. 配置文件支持中文，注意编码问题
4. 配置分组，考虑通过嵌套配置类的方式实现

## RPC Mock

1. 完善 Mock 的逻辑，支持更多类型的默认值生成，考虑使用 Faker 之类的库来伪造数据生成，生成默认值

## 序列化

1. 实现更多不同协议的序列化器，比如 `Protobuf`
2. 序列化工厂懒加载的方式创建序列化器实例 ✅

## SPI

1. `SpiLoader` 支持懒加载，获取实例时才加载对应的类 ✅

## 注册中心

1. 完善服务注册信息：节点注册时间等等
2. 实现更多注册中心：比如 Redis
3. 保证注册中心的高可用：集群
4. 服务注册信息失效的兜底策略：如果有消费端调用节点时发现节点失效，可以考虑是否需要从注册中心更新服务注册信息、或者强制更新本地缓存
5. 注册中心 Key 监听，采用观察者模式实现：定义一个 `Listener` 接口，根据 `watch key`
   的变更去调用 `Listener` 的不同方法

## 自定义协议

1. 定义一个占用空间更少的 RPC 协议的消息结构，比如 序列化字段目前占用 8bit，但其实总共也就几种序列化方式，能够更精简等等

## 负载均衡

1. 实现更多算法的负载均衡器，比如最少活跃数负载均衡器，选择当前正在处理请求的数量最少的服务提供者
2. 自定义一致性 Hash 算法中的 Hash 算法，比如根据请求客户端的 IP 地址来计算 Hash 值，保证同 IP
   的请求发送给相同的服务提供者

## 重试机制

1. 新增更多的不同类型的重试器

## 容错机制

1. 实现 `Fail-Back` 机制，参考 Dubbo Mock 能力，让消费端调用失败后执行本地服务和方法 ✅
2. 实现 `Fail-Over` 机制，利用容错上下文传递服务节点参数和本地调用的服务节点 ✅
3. 实现更多容错方案，比如限流、熔断、超时控制等；或者将重试机制作为容错机制的一种策略来实现

## 启动机制
1. Starter 支持读取 yml / yaml 配置文件来启动 RPC 框架
2. 服务提供者启动逻辑也可以将 bean 后置执行改为「使用组件扫描」